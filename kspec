#!/usr/bin/env bash
set -euo pipefail

# kspec — Spec-driven workflow for Kiro CLI (Q-compatible)
# - AU date folders: .kspec/specs/DD-MM-YYYY-<slug>/
# - /init: scaffolds .kspec templates, Project Steering (.kiro/steering/*), and Kiro/Q CLI agents (.kiro/agents/*)
# - Phase gating + review gates: ANALYZE (read-only) → APPLY → CREATE-SPEC → CREATE-TASKS → EXECUTE
# - OAS sync, memory harvesting, CI checks, and fast/headless mode
#
# Environment:
#   KSPEC_DATE=DD-MM-YYYY   override date used for folder naming
#   KSPEC_FAST=1            add --no-interactive (good for CI/headless)
#   KSPEC_FORCE=1           allow /init to overwrite existing agent JSONs
#   KSPEC_AUTO_EXEC=0       disable automatic command execution (default: enabled)
#   KSPEC_EXEC_DRY_RUN=1    show commands without executing (overrides KSPEC_AUTO_EXEC)

QOS_DIR=".kspec"
AGENTS_DIR=".kiro/agents"
RULES_DIR=".kiro/steering"
CURRENT_SPEC_FILE="${QOS_DIR}/.current_spec"
TODAY="${KSPEC_DATE:-$(date +%d-%m-%Y)}"   # AU format

die(){ printf 'Error: %s\n' "$*" >&2; exit 1; }
slugify(){ 
  # Take first 50 chars, convert to lowercase, replace spaces with hyphens, remove special chars
  printf '%s' "$1" | head -c 50 | tr '[:upper:]' '[:lower:]' | sed -E 's/[[:space:]]+/-/g; s/[^a-z0-9_-]+//g; s/^-+|-+$//g'; 
}
ensure_dir(){ mkdir -p "$1"; }
exists(){ [[ -e "$1" ]]; }
read_or_empty(){ [[ -f "$1" ]] && cat "$1" || printf ''; }

# Find existing spec folder by slug (searches all dates)
find_spec_folder(){
  local slug="$1"
  local current_spec
  
  # First, check if there's a current spec pointer
  if [[ -f "${CURRENT_SPEC_FILE}" ]]; then
    current_spec="$(cat "${CURRENT_SPEC_FILE}")"
    # Check if current spec matches the slug
    if [[ -d "$current_spec" && "$current_spec" == *"${slug}"* ]]; then
      printf '%s' "$current_spec"
      return 0
    fi
  fi
  
  # Find all folders matching the slug pattern
  local matches
  mapfile -t matches < <(find "${QOS_DIR}/specs" -maxdepth 1 -type d -name "*${slug}*" 2>/dev/null | sort -r)
  
  if [[ ${#matches[@]} -eq 0 ]]; then
    return 1
  elif [[ ${#matches[@]} -eq 1 ]]; then
    printf '%s' "${matches[0]}"
    return 0
  else
    # Multiple matches found
    printf 'Multiple spec folders found matching "%s":\n' "$slug" >&2
    local i=1
    for match in "${matches[@]}"; do
      printf '  %d) %s\n' "$i" "$(basename "$match")" >&2
      ((i++))
    done
    printf '\nPlease specify the exact folder name or use a more specific feature name.\n' >&2
    printf 'Tip: Use the full date prefix (DD-MM-YYYY-slug) to be specific.\n' >&2
    return 1
  fi
}

# Get current spec or prompt user to select one
get_or_select_spec(){
  local current_spec
  
  # Check if there's a current spec
  if [[ -f "${CURRENT_SPEC_FILE}" ]]; then
    current_spec="$(cat "${CURRENT_SPEC_FILE}")"
    if [[ -d "$current_spec" ]]; then
      printf '%s' "$current_spec"
      return 0
    fi
  fi
  
  # No current spec, find all specs
  local specs
  mapfile -t specs < <(find "${QOS_DIR}/specs" -maxdepth 1 -type d ! -name "specs" 2>/dev/null | sort -r)
  
  if [[ ${#specs[@]} -eq 0 ]]; then
    die "No spec folders found. Run /create-spec first."
  elif [[ ${#specs[@]} -eq 1 ]]; then
    # Only one spec, use it
    printf '%s' "${specs[0]}"
    printf '%s\n' "${specs[0]}" > "${CURRENT_SPEC_FILE}"
    return 0
  else
    # Multiple specs, prompt user
    printf 'Multiple spec folders found. Please select one:\n' >&2
    local i=1
    for spec in "${specs[@]}"; do
      printf '  %d) %s\n' "$i" "$(basename "$spec")" >&2
      ((i++))
    done
    printf '\nEnter number (1-%d): ' "${#specs[@]}" >&2
    read -r selection
    
    if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le "${#specs[@]}" ]]; then
      local selected_spec="${specs[$((selection-1))]}"
      printf '%s' "$selected_spec"
      printf '%s\n' "$selected_spec" > "${CURRENT_SPEC_FILE}"
      return 0
    else
      die "Invalid selection. Please run the command again."
    fi
  fi
}

# Add KSPEC_FAST flags
kspec_chat_flags(){
  if [[ "${KSPEC_FAST:-0}" = "1" ]]; then
    printf -- "--no-interactive"
  else
    printf ''
  fi
}

# Detect CLI binary (Kiro preferred, Q fallback)
detect_cli_bin(){
  if command -v kiro-cli >/dev/null 2>&1; then
    printf 'kiro-cli'
  elif command -v q >/dev/null 2>&1; then
    printf 'q'
  else
    die "Neither 'kiro-cli' nor 'q' found on PATH. Install Kiro CLI or Amazon Q CLI first."
  fi
}

CLI_BIN="${CLI_BIN:-$(detect_cli_bin)}"

info(){
  printf '[kspec] %s\n' "$*"
}

debug(){
  if [[ "${KSPEC_DEBUG:-0}" = "1" ]]; then
    printf '[kspec:debug] %s\n' "$*"
  fi
}

# ---------- Core paths and helpers ----------

ensure_core_dirs(){
  ensure_dir "${QOS_DIR}/instructions/core"
  ensure_dir "${QOS_DIR}/instructions/meta"
  ensure_dir "${QOS_DIR}/standards"
  ensure_dir "${QOS_DIR}/specs"
  ensure_dir "${QOS_DIR}/tasks"
  ensure_dir "${QOS_DIR}/memory"
  ensure_dir "${QOS_DIR}/examples"
  ensure_dir "${AGENTS_DIR}"
  ensure_dir "${RULES_DIR}"
}

# ---------- Built-in templates (used if repo/global templates absent) ----------
builtin_pre_flight(){ cat <<'MD'
# Pre-Flight
- Detect language/framework, build tool, test runner.
- Verify env & secrets; confirm branch/commit conventions.
- Identify sub-tasks suited for TDD; outline risk gates.
MD
}
builtin_analysis(){ cat <<'MD'
# Analysis
- Primary tech stack, frameworks, libraries.
- Key bounded contexts / domains.
- Observed architecture patterns (layers, modules, boundaries).
- Risks, smells, and complexity hotspots.
MD
}
builtin_standards_tech_stack(){ cat <<'MD'
# Tech Stack Standards
- Document primary languages/frameworks and minimum supported versions.
- Document build tools, package managers, and test runners.
- Document supported deployment targets and environments.
MD
}
builtin_standards_code_style(){ cat <<'MD'
# Code Style & Structure
- Enforce consistent naming conventions and file/folder layout.
- Use linters/formatters appropriate for each language.
- Document module boundaries and domain ownership.
MD
}
builtin_meta_feature(){ cat <<'MD'
# Feature Meta
- Business owner:
- Tech owner:
- Related tickets/links:
- Non-functional requirements (performance, security, compliance):
MD
}
builtin_spec_lite(){ cat <<'MD'
# Spec Lite

## Summary
- Short description of the feature/change.

## Acceptance Criteria
- [ ] Criterion 1
- [ ] Criterion 2

## Risks & Assumptions
- Risks:
- Assumptions:
MD
}
builtin_tasks_template(){ cat <<'MD'
# Tasks

1. [ ] Task 1
2. [ ] Task 2
3. [ ] Task 3
MD
}
builtin_memory_template(){ cat <<'MD'
# Memory

## Decisions
- Decision 1

## Glossary
- Term: Definition

## Follow-ups
- [ ] Follow-up 1
MD
}

# ---------- Agent authoring ----------

write_agent(){
  local name="$1" content="$2" path
  path="${AGENTS_DIR}/${name}.json"

  if [[ -f "$path" && "${KSPEC_FORCE:-0}" != "1" ]]; then
    printf 'Agent exists, skipping: %s\n' "$path"
    return 0
  fi

  printf '%s\n' "$content" > "$path"
  printf 'Agent written: %s\n' "$path"
}

author_agents(){
  mkdir -p "${AGENTS_DIR}"

  # NOTE:
  # These agents use Kiro CLI's built-in tool names with toolsSettings for permissions.

  write_agent "kspec-analyse" "$(cat <<'JSON'
{
  "name": "kspec-analyse",
  "description": "Read-only analysis; propose standards diffs; never write.",
  "prompt": "Analyse the repository. Deliver: (1) primary tech stack and architecture overview, (2) identified bounded contexts/domains, (3) risks/smells, (4) suggestions for improving standards and steering docs. Use .kiro/steering/*.md as the authoritative rules and .kspec/standards/*.md as derived standards. Do not modify any files; operate read-only. At the end, summarise next recommended kspec phase.",
  "allowedTools": ["read"],
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    }
  }
}
JSON
)"

  write_agent "kspec-apply-standards" "$(cat <<'JSON'
{
  "name": "kspec-apply-standards",
  "description": "Apply or propose changes to .kspec/standards based on steering docs and repo reality.",
  "prompt": "Goal: Align .kspec/standards with .kiro/steering and actual repo state. Steps: (1) Read .kiro/steering/*.md and .kspec/standards/*.md, (2) Propose specific edits to bring standards into compliance with steering while reflecting reality, (3) When asked, write updated standards markdown files under .kspec/standards. Be explicit about any deviations or approved exceptions. Treat .kiro/steering as authoritative.",
  "allowedTools": ["read", "write"],
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/standards/**"]
    }
  }
}
JSON
)"

  write_agent "kspec-create-spec" "$(cat <<'JSON'
{
  "name": "kspec-create-spec",
  "description": "Create spec.md and spec-lite.md for a feature; use steering and standards snapshot.",
  "prompt": "You are creating a feature specification. The feature folder path will be provided in the user message. IMPORTANT: Use the 'read' tool to read files and directories. To read a directory, use read with mode 'Directory'. To read files, use read with mode 'Line'. Steps: (1) Use read tool to list .kiro/steering/ directory, (2) Use read tool to read each steering file, (3) Use read tool to list .kspec/standards/ directory, (4) Use read tool to read each standards file, (5) Use write tool to create spec.md in the feature folder with: problem/context, requirements (functional + non-functional), constraints, high-level design, and references to steering docs, (6) Use write tool to create spec-lite.md with a condensed version. If there are conflicts between steering and standards, treat .kiro/steering as authoritative. At the end, suggest: run kspec /create-tasks with the feature name.",
  "allowedTools": ["read", "write"],
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/specs/**"]
    }
  }
}
JSON
)"

  write_agent "kspec-create-tasks" "$(cat <<'JSON'
{
  "name": "kspec-create-tasks",
  "description": "Turn spec.md into a numbered, TDD-ready tasks.md using the standards snapshot.",
  "prompt": "You are creating implementation tasks from a feature specification. The feature folder path will be provided in the user message. Read the spec.md and spec-lite.md from the feature folder and generate or refine tasks.md as a numbered, TDD-friendly checklist. CRITICAL: Use checkbox format for all tasks: '1. [ ] Task description'. This enables task completion tracking and resume functionality. Reference specific spec sections for each task. Assume .kspec/standards and .kiro/steering are in sync; if you notice contradictions, call them out and propose a follow-up standards reconcile. At the end, suggest the next step: run kspec /execute-tasks with the feature name.",
  "allowedTools": ["read", "write"],
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/specs/**"]
    }
  }
}
JSON
)"

  write_agent "kspec-execute-tasks" "$(cat <<'JSON'
{
  "name": "kspec-execute-tasks",
  "description": "Guided execution with automatic command execution by default.",
  "prompt": "You are executing implementation tasks. The feature folder path will be provided in the user message. Execute tasks using TDD: for each task in tasks.md, (1) identify incomplete tasks ([ ] checkboxes), (2) resume from first incomplete task, (3) restate the goal, (4) propose code changes, (5) propose tests, (6) suggest and execute commands, (7) CRITICAL: mark task complete by updating tasks.md - change [ ] to [x]. By default, commands are executed automatically (KSPEC_AUTO_EXEC=1 by default). Set KSPEC_AUTO_EXEC=0 to disable automatic execution, or KSPEC_EXEC_DRY_RUN=1 to only show commands without executing. Never run destructive commands without explicit confirmation. Always log executed commands to execution.log in the feature folder. After completing each task, write the updated tasks.md file with [x] for completed tasks to enable resume functionality.",
  "allowedTools": ["read", "write", "shell"],
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/specs/**", "./**"]
    },
    "shell": {
      "autoAllowReadonly": true
    }
  }
}
JSON
)"

  write_agent "kspec-harvest-memory" "$(cat <<'JSON'
{
  "name": "kspec-harvest-memory",
  "description": "Summarise decisions, glossary, and follow-ups into .kspec/memory.",
  "prompt": "Read relevant specs, tasks, and recent changes under .kspec/specs, .kspec/tasks, and the repo. Summarise: (1) key decisions, (2) glossary of terms, (3) follow-ups and risks. Write or update files under .kspec/memory (e.g., decisions.md, glossary.md, follow-ups.md). Call out where steering docs (.kiro/steering) should be updated and propose concrete edits.",
  "allowedTools": ["read", "write"],
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/memory/**"]
    }
  }
}
JSON
)"

  # Code Review Agent - inspired by GSD's verification phase
  write_agent "kspec-review" "$(cat <<'JSON'
{
  "name": "kspec-review",
  "description": "Code review agent: analyze changes, check standards compliance, suggest improvements.",
  "prompt": "You are a code review specialist. Your role is to review code changes and ensure quality.\n\nReview Process:\n1. Read the current spec and tasks from .kspec/specs/\n2. Analyze recent code changes (use git diff or read modified files)\n3. Check compliance with:\n   - .kiro/steering/*.md (authoritative rules)\n   - .kspec/standards/*.md (derived standards)\n4. Evaluate:\n   - Code quality and readability\n   - Test coverage and quality\n   - Security concerns\n   - Performance implications\n   - Error handling\n   - Documentation\n5. Provide actionable feedback with specific line references\n6. Suggest improvements with code examples\n\nOutput Format:\n- Summary: Overall assessment (APPROVE/REQUEST_CHANGES/COMMENT)\n- Compliance: Standards violations found\n- Issues: Categorized by severity (Critical/Major/Minor/Suggestion)\n- Improvements: Specific recommendations\n- Tests: Missing test coverage\n\nBe constructive and specific. Reference steering docs when citing standards.",
  "allowedTools": ["read", "shell"],
  "keyboardShortcut": "ctrl+r",
  "welcomeMessage": "Ready to review code. What would you like me to review?",
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "shell": {
      "allowedCommands": ["git diff*", "git log*", "git status*", "git show*"],
      "autoAllowReadonly": true
    }
  }
}
JSON
)"

  # Unit Test Agent - focused on test generation and TDD
  write_agent "kspec-test" "$(cat <<'JSON'
{
  "name": "kspec-test",
  "description": "Unit test specialist: generate tests, improve coverage, TDD guidance.",
  "prompt": "You are a testing specialist focused on TDD and comprehensive test coverage.\n\nCapabilities:\n1. Generate unit tests for existing code\n2. Guide TDD workflow (Red → Green → Refactor)\n3. Analyze test coverage gaps\n4. Improve existing tests\n5. Create test fixtures and mocks\n\nWorkflow:\n1. Read .kiro/steering/testing-standards.md for testing conventions\n2. Analyze the code to be tested\n3. Identify test scenarios:\n   - Happy path cases\n   - Edge cases\n   - Error conditions\n   - Boundary conditions\n4. Generate tests following project conventions\n5. Suggest test organization and naming\n\nTest Quality Checklist:\n- [ ] Tests are independent and isolated\n- [ ] Tests have clear arrange/act/assert structure\n- [ ] Tests cover edge cases\n- [ ] Tests are readable and maintainable\n- [ ] Mocks are used appropriately\n- [ ] Tests run fast\n\nOutput: Provide complete, runnable test code with explanations.",
  "allowedTools": ["read", "write", "shell"],
  "keyboardShortcut": "ctrl+t",
  "welcomeMessage": "Ready to help with testing. What would you like to test?",
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": ["**/*.test.*", "**/*.spec.*", "**/test/**", "**/tests/**", "**/__tests__/**"]
    },
    "shell": {
      "allowedCommands": ["npm test*", "yarn test*", "pnpm test*", "pytest*", "cargo test*", "go test*", "jest*", "vitest*"],
      "autoAllowReadonly": true
    }
  }
}
JSON
)"

  # Quick Mode Agent - for ad-hoc tasks without full spec workflow
  write_agent "kspec-quick" "$(cat <<'JSON'
{
  "name": "kspec-quick",
  "description": "Quick mode: fast ad-hoc tasks without full spec workflow.",
  "prompt": "You are in quick mode for fast, ad-hoc tasks that don't need full specification.\n\nUse Cases:\n- Bug fixes\n- Small features\n- Config changes\n- Refactoring\n- Documentation updates\n\nWorkflow:\n1. Understand the task\n2. Create a mini-plan (3-5 steps max)\n3. Execute with TDD where applicable\n4. Commit with clear message\n5. Log to .kspec/quick/ for tracking\n\nRules:\n- Keep changes focused and atomic\n- Follow existing patterns in .kiro/steering/\n- Write tests for any logic changes\n- Commit after each logical unit\n\nTracking:\n- Create .kspec/quick/YYYY-MM-DD-<slug>.md for each quick task\n- Include: task description, changes made, files modified\n\nThis is NOT for:\n- Large features (use /create-spec)\n- Architectural changes\n- Breaking changes",
  "allowedTools": ["read", "write", "shell"],
  "keyboardShortcut": "ctrl+q",
  "welcomeMessage": "Quick mode active. What's the task?",
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/quick/**", "./**"]
    },
    "shell": {
      "autoAllowReadonly": true
    }
  }
}
JSON
)"

  # Debug Agent - systematic debugging with state tracking
  write_agent "kspec-debug" "$(cat <<'JSON'
{
  "name": "kspec-debug",
  "description": "Debug specialist: systematic debugging with hypothesis tracking.",
  "prompt": "You are a debugging specialist using systematic problem-solving.\n\nDebug Methodology:\n1. REPRODUCE: Understand and reproduce the issue\n2. HYPOTHESIZE: Form hypotheses about root cause\n3. TEST: Test each hypothesis systematically\n4. FIX: Implement minimal fix\n5. VERIFY: Confirm fix and no regressions\n6. DOCUMENT: Record findings\n\nState Tracking:\n- Track hypotheses in .kspec/debug/current-debug.md\n- Log findings and eliminated causes\n- Record successful fix approach\n\nTools:\n- Read logs and error messages\n- Add debug logging temporarily\n- Use debugger commands\n- Analyze stack traces\n- Check recent changes (git log/diff)\n\nOutput Format:\n```\n## Issue: [description]\n## Reproduction: [steps]\n## Hypotheses:\n1. [ ] Hypothesis A - [status]\n2. [ ] Hypothesis B - [status]\n## Root Cause: [finding]\n## Fix: [solution]\n## Verification: [test results]\n```\n\nNever guess - always verify with evidence.",
  "allowedTools": ["read", "write", "shell"],
  "keyboardShortcut": "ctrl+d",
  "welcomeMessage": "Debug mode active. Describe the issue or error.",
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/debug/**", "./**"]
    },
    "shell": {
      "autoAllowReadonly": true
    }
  }
}
JSON
)"

  # Orchestrator Agent - coordinates multi-agent workflows
  write_agent "kspec-orchestrator" "$(cat <<'JSON'
{
  "name": "kspec-orchestrator",
  "description": "Orchestrator: coordinates complex tasks across multiple specialized agents.",
  "prompt": "You are the kspec orchestrator, coordinating complex workflows across specialized agents.\n\nAvailable Agents (switch with /agent swap or keyboard shortcuts):\n- kspec-analyse (Ctrl+A): Read-only analysis\n- kspec-apply-standards: Update standards\n- kspec-create-spec: Create specifications\n- kspec-create-tasks: Generate task lists\n- kspec-execute-tasks: Execute with TDD\n- kspec-review (Ctrl+R): Code review\n- kspec-test (Ctrl+T): Testing specialist\n- kspec-quick (Ctrl+Q): Quick ad-hoc tasks\n- kspec-debug (Ctrl+D): Debugging\n- kspec-harvest-memory: Capture learnings\n\nOrchestration Patterns:\n\n1. NEW FEATURE:\n   analyse → create-spec → create-tasks → execute-tasks → review → harvest-memory\n\n2. BUG FIX:\n   debug → quick OR (create-spec → execute-tasks) → review\n\n3. REFACTORING:\n   analyse → create-spec → test (add coverage) → execute-tasks → review\n\n4. CODE REVIEW:\n   review → (debug if issues) → test (if coverage gaps)\n\nYour Role:\n- Understand the user's goal\n- Recommend the right agent sequence\n- Track progress in .kspec/state.md\n- Suggest when to switch agents\n- Ensure nothing falls through cracks\n\nState Management:\n- Read/write .kspec/state.md for workflow state\n- Track: current phase, completed steps, blockers, next actions",
  "allowedTools": ["read", "write"],
  "keyboardShortcut": "ctrl+o",
  "welcomeMessage": "Orchestrator ready. What would you like to accomplish?",
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/state.md", ".kspec/workflow/**"]
    }
  }
}
JSON
)"
}

# ---------- Standards / steering helpers ----------

rules_fingerprint(){
  # portable fingerprint of all rule files (order-insensitive)
  local hash_cmd
  if command -v sha256sum >/dev/null 2>&1; then
    hash_cmd="sha256sum"
  elif command -v shasum >/dev/null 2>&1; then
    hash_cmd="shasum -a 256"
  else
    die "Neither sha256sum nor shasum found. Cannot compute fingerprint."
  fi
  
  find "${RULES_DIR}" -type f -maxdepth 1 2>/dev/null \
    | sort \
    | xargs cat 2>/dev/null \
    | $hash_cmd \
    | awk '{print $1}'
}

read_rules_fingerprint(){
  [[ -f "${QOS_DIR}/.rules_fingerprint" ]] && cat "${QOS_DIR}/.rules_fingerprint" || printf ''
}

write_rules_fingerprint(){
  rules_fingerprint > "${QOS_DIR}/.rules_fingerprint"
}

check_steering_drift(){
  local current_fp stored_fp
  current_fp="$(rules_fingerprint)"
  stored_fp="$(read_rules_fingerprint)"
  
  if [[ -n "$stored_fp" && "$current_fp" != "$stored_fp" ]]; then
    printf '⚠️  Warning: Steering docs have changed since last sync.\n' >&2
    printf '   Run: kspec /apply-standards\n' >&2
    printf '   Continue anyway? (y/N): ' >&2
    read -r response
    [[ "$response" =~ ^[Yy]$ ]] || exit 1
  fi
}

get_context_block(){
  # Project-level context that kspec agents should always see.
  # Steering (.kiro/steering) and agents (.kiro/agents) are auto-included by Kiro.
  # We include examples & memory explicitly where helpful.
  cat <<EOF
kspec context:
- Today: ${TODAY}
- kspec dir: ${QOS_DIR}/
- Steering: ${RULES_DIR}/ (authoritative project rules)
- Standards: ${QOS_DIR}/standards/ (derived from steering)
- Specs: ${QOS_DIR}/specs/
- Tasks: ${QOS_DIR}/tasks/
- Memory: ${QOS_DIR}/memory/
EOF
}

# ---------- Commands ----------

cmd_init(){
  info "Initializing kspec..."

  ensure_core_dirs

  # Instructions templates
  [[ -f "${QOS_DIR}/instructions/core/pre-flight.md" ]] || builtin_pre_flight > "${QOS_DIR}/instructions/core/pre-flight.md"
  [[ -f "${QOS_DIR}/instructions/core/analysis.md" ]]   || builtin_analysis > "${QOS_DIR}/instructions/core/analysis.md"
  [[ -f "${QOS_DIR}/instructions/meta/feature.md" ]]    || builtin_meta_feature > "${QOS_DIR}/instructions/meta/feature.md"
  [[ -f "${QOS_DIR}/standards/tech-stack.md" ]]         || builtin_standards_tech_stack > "${QOS_DIR}/standards/tech-stack.md"
  [[ -f "${QOS_DIR}/standards/code-style.md" ]]         || builtin_standards_code_style > "${QOS_DIR}/standards/code-style.md"
  [[ -f "${QOS_DIR}/memory/template.md" ]]              || builtin_memory_template > "${QOS_DIR}/memory/template.md"
  [[ -f ".kspec/examples/spec-lite.example.md" ]]         || builtin_spec_lite > ".kspec/examples/spec-lite.example.md"
  [[ -f ".kspec/examples/tasks.example.md" ]]             || builtin_tasks_template > ".kspec/examples/tasks.example.md"
  printf 'Initialized %s templates\n' "${QOS_DIR}"

  # Kiro steering docs (foundational files per Kiro documentation)
  mkdir -p "${RULES_DIR}"
  
  [[ -f "${RULES_DIR}/product.md" ]] || cat > "${RULES_DIR}/product.md" <<'MD'
# Product Overview

## Purpose
Define your product's purpose, target users, key features, and business objectives.

## Target Users
- Who are the primary users?
- What problems are we solving for them?

## Key Features
- List the main features and capabilities
- Prioritize by importance

## Business Objectives
- What are the success metrics?
- What are the business goals?

## Technical Constraints
- Compliance requirements (e.g., SOC2, GDPR)
- Performance requirements
- Scalability needs
MD

  [[ -f "${RULES_DIR}/tech.md" ]] || cat > "${RULES_DIR}/tech.md" <<'MD'
# Technology Stack

## Runtime & Languages
- Primary language and version
- Runtime environment

## Frameworks & Libraries
- Web framework
- Testing framework
- Key libraries

## Development Tools
- Build tools
- Package managers
- Linters and formatters

## Infrastructure
- Deployment targets
- Cloud providers
- CI/CD tools

## Technical Constraints
- Minimum supported versions
- Deprecated technologies to avoid
- Required dependencies
MD

  [[ -f "${RULES_DIR}/structure.md" ]] || cat > "${RULES_DIR}/structure.md" <<'MD'
# Project Structure

## File Organization
- Directory structure and layout
- Module boundaries
- Feature-based vs layer-based organization

## Naming Conventions
- File naming patterns
- Variable naming (camelCase, snake_case, etc.)
- Class and function naming
- Constants and environment variables

## Import Patterns
- Import ordering
- Absolute vs relative imports
- Barrel exports

## Architectural Decisions
- Design patterns used
- Separation of concerns
- Dependency injection approach
- State management strategy

## Code Organization
- Where to put business logic
- Where to put utilities
- Where to put types/interfaces
- Where to put tests
MD

  # Additional custom steering files
  [[ -f "${RULES_DIR}/api-standards.md" ]] || cat > "${RULES_DIR}/api-standards.md" <<'MD'
# API Standards

## REST Conventions
- Endpoint naming patterns
- HTTP methods usage
- Status codes
- Versioning strategy

## Request/Response Format
- JSON structure
- Error response format
- Pagination approach
- Filtering and sorting

## Authentication & Authorization
- Authentication method (JWT, OAuth, etc.)
- Authorization patterns
- Token management

## Documentation
- OpenAPI/Swagger requirements
- Endpoint documentation standards
- Example requests/responses
MD

  [[ -f "${RULES_DIR}/testing-standards.md" ]] || cat > "${RULES_DIR}/testing-standards.md" <<'MD'
# Testing Standards

## Testing Approach
- TDD (Test-Driven Development) required
- Test-first methodology
- Red → Green → Refactor cycle

## Test Types
- Unit tests: Test individual functions/methods
- Integration tests: Test component interactions
- E2E tests: Test complete user flows

## Testing Libraries
- Unit test framework
- Assertion library
- Mocking approach

## Coverage Requirements
- Minimum coverage thresholds
- Critical paths that must be tested
- What to test vs what to skip

## Test Organization
- Test file naming
- Test file location
- Test structure and patterns
MD

  [[ -f "${RULES_DIR}/security.md" ]] || cat > "${RULES_DIR}/security.md" <<'MD'
# Security Standards

## Authentication & Authorization
- Authentication requirements
- Authorization patterns
- Session management

## Data Protection
- Encryption requirements
- Sensitive data handling
- PII protection

## Input Validation
- Input sanitization rules
- Validation patterns
- SQL injection prevention
- XSS prevention

## Secrets Management
- Never commit secrets to code
- Use environment variables
- Secret rotation policies

## Logging & Monitoring
- What to log
- What NOT to log (passwords, tokens, PII)
- Security event monitoring
MD

  printf 'Initialized Kiro Steering docs in %s\n' "${RULES_DIR}"

  # Agents (idempotent; set KSPEC_FORCE=1 to overwrite)
  author_agents
  printf 'Agents initialised in %s\n' "${AGENTS_DIR}"

  printf '\nUse either the script or agents:\n'
  printf '  Script: kspec /analyse | /apply-standards | /create-spec "Feature" | /create-tasks | /execute-tasks\n'
  printf '  Agent:  %s chat --agent kspec-analyse\n' "${CLI_BIN}"

  write_rules_fingerprint

  info "kspec init complete."
}

cmd_analyse(){
  info "Running project analysis..."

  local msg="Analyse the entire repository and project.

Deliver:
1. Primary tech stack and architecture overview
   - Languages, frameworks, libraries used
   - Build tools, package managers, test runners
   - Deployment targets and environments
2. Identified bounded contexts/domains
   - Key modules and their responsibilities
   - Domain boundaries and relationships
3. Risks, smells, and complexity hotspots
   - Code quality issues
   - Technical debt
   - Security concerns
   - Performance bottlenecks
4. Suggestions for improving standards and steering docs
   - Recommended updates to .kiro/steering/*.md
   - Recommended updates to .kspec/standards/*.md
   - Gaps in current documentation

Use .kiro/steering/*.md as the authoritative rules and .kspec/standards/*.md as derived standards.
Do not modify any files; operate read-only.

At the end, summarise:
- Current state of the project
- Recommended next steps for kspec setup
- Suggested standards to add or update
- Next recommended kspec phase (e.g., run /apply-standards)

$(get_context_block)"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_apply_standards(){
  info "Running apply-standards phase..."

  local msg="Align .kspec/standards with .kiro/steering and repo reality.

Steps:
1. Read .kiro/steering/*.md (project rules - authoritative)
2. Read .kspec/standards/*.md (current standards - derived)
3. Analyze repo to understand actual tech stack and practices
4. Identify gaps and conflicts between steering, standards, and reality
5. Propose specific edits to bring standards into compliance
6. Write updated standards markdown files under .kspec/standards

Deliverables:
- Updated .kspec/standards/tech-stack.md with:
  * Languages, frameworks, versions
  * Build tools and package managers
  * Test runners and CI/CD tools
  * Deployment targets
- Updated .kspec/standards/code-style.md with:
  * Naming conventions
  * File/folder structure
  * Linting and formatting rules
  * Module boundaries

Be explicit about:
- Any deviations from steering docs (with justification)
- Approved exceptions
- Conflicts that need steering doc updates

Treat .kiro/steering as authoritative.

At the end, summarise:
- What was updated
- Any conflicts found
- Recommended steering doc updates

$(get_context_block)"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"

  write_rules_fingerprint
}

cmd_create_spec(){
  local feature="${1:-}"
  [[ -n "$feature" ]] || die "Usage: kspec /create-spec \"Feature Name\""

  check_steering_drift

  local slug folder msg
  slug="$(slugify "$feature")"
  folder="${QOS_DIR}/specs/${TODAY}-${slug}"
  ensure_dir "$folder"

  printf '%s\n' "$folder" > "${CURRENT_SPEC_FILE}"

  msg="Create a feature specification for: ${feature}

Feature folder: ${folder}

Instructions:
1. Read the steering documents from .kiro/steering/ directory
2. Read the standards from .kspec/standards/ directory
3. Create ${folder}/spec.md with:
   - Problem/Context section
   - Functional Requirements
   - Non-Functional Requirements
   - Constraints
   - High-Level Design
   - References to steering docs
4. Create ${folder}/spec-lite.md with a condensed version

The steering docs (.kiro/steering/) are authoritative. If there are conflicts with standards, note them.

At the end, suggest: Next step → run: kspec /create-tasks \"${feature}\"

$(get_context_block)"

  info "Feature folder: ${folder}"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_create_tasks(){
  local feature="${1:-}"
  local folder msg
  
  check_steering_drift
  
  if [[ -n "$feature" ]]; then
    # Feature name provided, find by slug
    local slug
    slug="$(slugify "$feature")"
    folder="$(find_spec_folder "$slug")"
    
    if [[ -z "$folder" || ! -d "$folder" ]]; then
      die "Feature folder not found for '${feature}'. Run /create-spec first."
    fi
  else
    # No feature name, use current spec or prompt
    folder="$(get_or_select_spec)"
  fi

  msg="Generate implementation tasks from the feature specification.

Feature folder: ${folder}

Instructions:
1. Read ${folder}/spec.md and ${folder}/spec-lite.md thoroughly
2. Generate ${folder}/tasks.md as a numbered, TDD-friendly checklist

Task Format:
- CRITICAL: Use checkbox format for all tasks: \"1. [ ] Task description\"
- This enables task completion tracking and resume functionality
- Example format:
  1. [ ] Create user model with validation
  2. [ ] Implement authentication service
  3. [ ] Add API endpoints for user management

Task Structure:
- Group tasks by user story or feature area
- For each task, specify:
  * Task number and description with [ ] checkbox
  * Test to write first (TDD approach)
  * Implementation steps
  * Acceptance criteria
  * Dependencies on other tasks
- Mark tasks that can run in parallel with [P]
- Include file paths where changes should occur

Task Ordering:
- Models/types first
- Services/business logic second
- API endpoints/controllers third
- UI components last
- Tests before implementation for each layer

Reference specific spec sections for each task.
Assume .kspec/standards and .kiro/steering are in sync.
If you notice contradictions, call them out and propose a follow-up standards reconcile.

At the end, summarise:
- Total number of tasks
- Estimated complexity
- Critical path tasks
- Suggest: Next step → run: kspec /execute-tasks

$(get_context_block)"

  info "Feature folder: ${folder}"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_execute_tasks(){
  local feature="${1:-}"
  local folder msg
  
  check_steering_drift
  
  if [[ -n "$feature" ]]; then
    # Feature name provided, find by slug
    local slug
    slug="$(slugify "$feature")"
    folder="$(find_spec_folder "$slug")"
    
    if [[ -z "$folder" || ! -d "$folder" ]]; then
      die "Feature folder not found for '${feature}'. Run /create-spec and /create-tasks first."
    fi
  else
    # No feature name, use current spec or prompt
    folder="$(get_or_select_spec)"
  fi

  msg="Execute implementation tasks using TDD approach.

Feature folder: ${folder}

CRITICAL SAFETY RULES:
⚠️  NEVER delete, remove, or modify .kiro/ or .kspec/ folders
⚠️  NEVER run commands that would overwrite these folders
⚠️  If a tool complains about .kiro/ or .kspec/ existing, work around it
⚠️  These folders contain project governance and specs - they are sacred
⚠️  If initialization tools conflict, use subdirectories or different approaches

Instructions:
1. Read ${folder}/tasks.md and ${folder}/spec.md
2. Identify incomplete tasks (those with [ ] checkboxes)
3. Resume from the first incomplete task
4. For each task in order:
   a) Restate the task goal and acceptance criteria
   b) Write the test first (TDD)
   c) Propose minimal code changes to make test pass
   d) Refactor if needed
   e) Suggest commands to run (build, test, lint)
   f) IMPORTANT: Mark task as complete by updating tasks.md - change [ ] to [x]
   g) Write the updated tasks.md file after each completed task

Task Completion:
- CRITICAL: After completing each task, update ${folder}/tasks.md
- Change the checkbox from [ ] to [x] for completed tasks
- Example: \"1. [ ] Task name\" becomes \"1. [x] Task name\"
- This enables resume functionality for interrupted work
- Always write the full updated tasks.md file

Resume Capability:
- If tasks.md has [x] marked tasks, skip them and resume from first [ ]
- Report which tasks are already complete
- Continue from where work was interrupted

Execution Strategy:
- Follow TDD: Red → Green → Refactor
- Write tests before implementation
- Keep changes minimal and focused
- Run tests after each task
- Mark task complete in tasks.md after tests pass
- Commit after each completed task (suggest commit message)

Command Execution:
- IMPORTANT: Always use non-interactive flags for commands
  * Use --yes, --no-interaction, -y flags where available
  * For npm: use --yes or -y
  * For create-next-app: use --yes or answer prompts with defaults
  * For package managers: use --non-interactive or --yes
- If tools complain about existing files/folders:
  * Create in subdirectories instead
  * Use --force only if safe (never for .kiro/ or .kspec/)
  * Modify the approach to work with existing structure
- By default, commands are executed automatically (KSPEC_AUTO_EXEC=1)
- Set KSPEC_AUTO_EXEC=0 to disable automatic execution
- Set KSPEC_EXEC_DRY_RUN=1 to only show commands without executing
- Never run destructive commands without explicit confirmation
- If a command requires user input, modify it to be non-interactive

Logging:
- Log all executed commands to ${folder}/execution.log
- Include timestamps and exit codes
- Note any errors or warnings

At the end, summarise:
- Tasks completed (X of Y)
- Tasks remaining
- Tests passing
- Any issues encountered
- If all tasks complete, suggest: Next step → run: kspec /harvest-memory
- If tasks remain, note that you can resume by running /execute-tasks again

$(get_context_block)"

  info "Feature folder: ${folder}"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_harvest_memory(){
  local feature="${1:-}"
  local folder=""
  
  if [[ -n "$feature" ]]; then
    # Feature name provided, find by slug
    local slug
    slug="$(slugify "$feature")"
    folder="$(find_spec_folder "$slug")"
    
    if [[ -z "$folder" || ! -d "$folder" ]]; then
      die "Feature folder not found for '${feature}'."
    fi
  else
    # No feature name, use current spec or prompt
    folder="$(get_or_select_spec)"
  fi
  
  info "Running memory harvest for: ${folder}"

  local msg="Harvest memory from the feature work.

Feature folder: ${folder}

Instructions:
1. Read ${folder}/spec.md, ${folder}/tasks.md, ${folder}/execution.log
2. Read recent changes in the repo related to this feature (git log, diffs)
3. Analyze implementation decisions and patterns used

Deliverables:

Create/Update .kspec/memory/decisions.md:
- Key architectural decisions made
- Technology choices and rationale
- Trade-offs considered
- Alternatives rejected and why
- Date and context for each decision

Create/Update .kspec/memory/glossary.md:
- Domain-specific terms and definitions
- Technical concepts introduced
- Acronyms and abbreviations
- Business terminology
- Links to relevant documentation

Create/Update .kspec/memory/follow-ups.md:
- Technical debt identified
- Future improvements needed
- Performance optimizations to consider
- Security concerns to address
- Refactoring opportunities
- Dependencies to upgrade

Steering Doc Updates:
- Identify patterns that should become standards
- Suggest updates to .kiro/steering/*.md
- Propose new steering docs if needed
- Note any deviations from current steering

At the end, summarise:
- Key learnings captured
- Number of decisions documented
- Critical follow-ups
- Recommended steering updates

$(get_context_block)"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_quick(){
  local task="${1:-}"
  [[ -n "$task" ]] || die "Usage: kspec /quick \"Task description\""

  local slug folder
  slug="$(slugify "$task")"
  folder="${QOS_DIR}/quick/${TODAY}-${slug}"
  ensure_dir "$folder"

  local msg="Quick mode task: ${task}

Task folder: ${folder}

Instructions:
1. Understand the task requirements
2. Create a mini-plan (3-5 steps max) in ${folder}/plan.md
3. Execute with TDD where applicable
4. Log changes to ${folder}/changes.md
5. Suggest commit message

Rules:
- Keep changes focused and atomic
- Follow patterns in .kiro/steering/
- Write tests for logic changes
- This is for small, quick tasks only

$(get_context_block)"

  info "Quick task folder: ${folder}"
  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_debug(){
  local issue="${1:-}"
  
  local folder="${QOS_DIR}/debug"
  ensure_dir "$folder"

  local msg="Debug mode activated.

Debug folder: ${folder}
${issue:+Issue: ${issue}}

Methodology:
1. REPRODUCE: Understand and reproduce the issue
2. HYPOTHESIZE: Form hypotheses about root cause
3. TEST: Test each hypothesis systematically
4. FIX: Implement minimal fix
5. VERIFY: Confirm fix and no regressions
6. DOCUMENT: Record findings in ${folder}/current-debug.md

Track your hypotheses and findings. Never guess - verify with evidence.

$(get_context_block)"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_review(){
  local target="${1:-}"
  
  local msg="Code review mode activated.

${target:+Review target: ${target}}

Review Process:
1. Analyze recent changes (git diff HEAD~1 or specified target)
2. Check compliance with .kiro/steering/*.md
3. Evaluate code quality, tests, security, performance
4. Provide actionable feedback

Output Format:
- Summary: APPROVE / REQUEST_CHANGES / COMMENT
- Issues by severity: Critical / Major / Minor / Suggestion
- Specific recommendations with code examples

$(get_context_block)"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_test(){
  local target="${1:-}"
  
  local msg="Test generation mode activated.

${target:+Target: ${target}}

Workflow:
1. Read .kiro/steering/testing-standards.md
2. Analyze code to be tested
3. Generate comprehensive tests:
   - Happy path cases
   - Edge cases
   - Error conditions
   - Boundary conditions
4. Follow project test conventions
5. Ensure tests are independent and fast

Provide complete, runnable test code.

$(get_context_block)"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_progress(){
  info "kspec Progress"
  printf '\n'
  
  # Current spec status
  if [[ -f "${CURRENT_SPEC_FILE}" ]]; then
    local current_spec
    current_spec="$(cat "${CURRENT_SPEC_FILE}")"
    printf 'Current Spec: %s\n' "$(basename "$current_spec")"
    
    if [[ -f "${current_spec}/tasks.md" ]]; then
      local total completed remaining
      total=$(grep -c '^\s*[0-9]*\.\s*\[' "${current_spec}/tasks.md" 2>/dev/null || echo 0)
      completed=$(grep -c '^\s*[0-9]*\.\s*\[x\]' "${current_spec}/tasks.md" 2>/dev/null || echo 0)
      remaining=$((total - completed))
      printf 'Tasks: %d/%d completed (%d remaining)\n' "$completed" "$total" "$remaining"
    fi
    
    printf '\nFiles:\n'
    for f in spec.md spec-lite.md tasks.md execution.log; do
      if [[ -f "${current_spec}/${f}" ]]; then
        printf '  ✓ %s\n' "$f"
      else
        printf '  ○ %s\n' "$f"
      fi
    done
  else
    printf 'No current spec selected.\n'
  fi
  
  printf '\nRecent Specs:\n'
  find "${QOS_DIR}/specs" -maxdepth 1 -type d ! -name "specs" 2>/dev/null | sort -r | head -5 | while read -r spec; do
    printf '  - %s\n' "$(basename "$spec")"
  done
  
  printf '\nQuick Tasks:\n'
  find "${QOS_DIR}/quick" -maxdepth 1 -type d ! -name "quick" 2>/dev/null | sort -r | head -5 | while read -r task; do
    printf '  - %s\n' "$(basename "$task")"
  done 2>/dev/null || printf '  (none)\n'
  
  printf '\nNext Steps:\n'
  if [[ ! -d "${QOS_DIR}" ]]; then
    printf '  → Run: kspec /init\n'
  elif [[ ! -f "${CURRENT_SPEC_FILE}" ]]; then
    printf '  → Run: kspec /create-spec "Feature Name"\n'
  elif [[ -f "${CURRENT_SPEC_FILE}" ]]; then
    current_spec="$(cat "${CURRENT_SPEC_FILE}")"
    if [[ ! -f "${current_spec}/spec.md" ]]; then
      printf '  → Spec creation in progress\n'
    elif [[ ! -f "${current_spec}/tasks.md" ]]; then
      printf '  → Run: kspec /create-tasks\n'
    else
      local remaining
      remaining=$(grep -c '^\s*[0-9]*\.\s*\[ \]' "${current_spec}/tasks.md" 2>/dev/null || echo 0)
      if [[ "$remaining" -gt 0 ]]; then
        printf '  → Run: kspec /execute-tasks (%d tasks remaining)\n' "$remaining"
      else
        printf '  → Run: kspec /review or /harvest-memory\n'
      fi
    fi
  fi
}

cmd_agents(){
  info "Available kspec Agents"
  printf '\n'
  printf 'Agent                    Shortcut  Purpose\n'
  printf '─────────────────────────────────────────────────────────────\n'
  printf 'kspec-analyse            -         Read-only project analysis\n'
  printf 'kspec-apply-standards    -         Update standards from steering\n'
  printf 'kspec-create-spec        -         Create feature specifications\n'
  printf 'kspec-create-tasks       -         Generate task lists from specs\n'
  printf 'kspec-execute-tasks      -         Execute tasks with TDD\n'
  printf 'kspec-review             Ctrl+R    Code review and quality check\n'
  printf 'kspec-test               Ctrl+T    Test generation specialist\n'
  printf 'kspec-quick              Ctrl+Q    Quick ad-hoc tasks\n'
  printf 'kspec-debug              Ctrl+D    Systematic debugging\n'
  printf 'kspec-orchestrator       Ctrl+O    Coordinate multi-agent workflows\n'
  printf 'kspec-harvest-memory     -         Capture decisions and learnings\n'
  printf '\n'
  printf 'Switch agents:\n'
  printf '  - Use keyboard shortcuts during chat\n'
  printf '  - Run: /agent swap (in kiro-cli)\n'
  printf '  - Run: kiro-cli --agent <agent-name>\n'
}

cmd_check_consistency(){
  info "Checking consistency between steering and standards..."

  local prompt="Check consistency between steering docs and kspec standards.

Steps:
1. Read .kiro/steering/*.md (project rules / constitution)
2. Read .kspec/standards/tech-stack.md and .kspec/standards/code-style.md (repo project standards)
3. Identify contradictions, gaps, and outdated sections
4. Summarise findings and recommend follow-ups (e.g., run /apply-standards)

DO NOT modify any files; this is read-only analysis."

  "${CLI_BIN}" chat $(kspec_chat_flags) "$prompt"
}

cmd_reconcile_rules_standards(){
  info "Reconciling steering (.kiro/steering) and standards (.kspec/standards)..."

  local prompt="Align .kspec/standards with .kiro/steering.

Steps:
1. Read .kiro/steering/*.md and the standards files
2. Propose specific edits to bring standards into compliance with steering while reflecting repo reality
3. Summarise the changes you recommend making

Do not modify files yourself during this run; just propose edits that can be applied by /apply-standards."

  "${CLI_BIN}" chat $(kspec_chat_flags) "$prompt"
}

cmd_status(){
  info "kspec Status"
  printf '\n'
  
  printf 'Environment:\n'
  printf '  CLI Binary: %s\n' "${CLI_BIN}"
  printf '  Date: %s\n' "${TODAY}"
  printf '  KSPEC_FAST: %s\n' "${KSPEC_FAST:-0}"
  printf '  KSPEC_FORCE: %s\n' "${KSPEC_FORCE:-0}"
  printf '  KSPEC_AUTO_EXEC: %s (default: 1)\n' "${KSPEC_AUTO_EXEC:-1}"
  printf '  KSPEC_EXEC_DRY_RUN: %s\n' "${KSPEC_EXEC_DRY_RUN:-0}"
  printf '  KSPEC_DEBUG: %s\n' "${KSPEC_DEBUG:-0}"
  printf '\n'
  
  if [[ -f "${CURRENT_SPEC_FILE}" ]]; then
    printf 'Current Spec: %s\n' "$(cat "${CURRENT_SPEC_FILE}")"
  else
    printf 'Current Spec: (none)\n'
  fi
  printf '\n'
  
  if [[ -f "${QOS_DIR}/.rules_fingerprint" ]]; then
    printf 'Steering Fingerprint: %s\n' "$(cat "${QOS_DIR}/.rules_fingerprint")"
  else
    printf 'Steering Fingerprint: (not initialized)\n'
  fi
  printf '\n'
  
  if [[ -d "${QOS_DIR}" ]]; then
    printf 'Initialized: yes\n'
    printf 'Specs: %d\n' "$(find "${QOS_DIR}/specs" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l | tr -d ' ')"
  else
    printf 'Initialized: no (run: kspec /init)\n'
  fi
}

cmd_show_help(){
  cat <<EOF
kspec - Spec-driven workflow for Kiro CLI

Usage:
  kspec /init                           Initialize kspec structure
  kspec /status                         Show environment status
  kspec /progress                       Show workflow progress and next steps
  kspec /agents                         List available agents and shortcuts

Core Workflow:
  kspec /analyse                        Analyze project (read-only)
  kspec /apply-standards                Update standards from steering
  kspec /create-spec "Feature Name"     Create feature specification
  kspec /create-tasks ["Feature"]       Generate tasks from spec
  kspec /execute-tasks ["Feature"]      Execute tasks with TDD
  kspec /harvest-memory ["Feature"]     Capture decisions and learnings

Quick Actions:
  kspec /quick "Task description"       Fast ad-hoc task (no full spec)
  kspec /review [target]                Code review mode
  kspec /test [target]                  Test generation mode
  kspec /debug [issue]                  Systematic debugging mode

Maintenance:
  kspec /check-consistency              Check steering vs standards
  kspec /reconcile-rules-standards      Propose alignment fixes

Examples:
  # Initial setup
  kspec /init
  kspec /analyse
  kspec /apply-standards
  
  # Feature development (full workflow)
  kspec /create-spec "User Authentication API"
  kspec /create-tasks
  kspec /execute-tasks
  kspec /review
  kspec /harvest-memory
  
  # Quick tasks (no spec needed)
  kspec /quick "Fix login button alignment"
  kspec /debug "API returns 500 on POST /users"
  kspec /test "src/services/auth.ts"

Agent Shortcuts (in kiro-cli chat):
  Ctrl+R  → kspec-review (code review)
  Ctrl+T  → kspec-test (testing)
  Ctrl+Q  → kspec-quick (quick tasks)
  Ctrl+D  → kspec-debug (debugging)
  Ctrl+O  → kspec-orchestrator (workflow coordination)

Environment Variables:
  KSPEC_DATE=DD-MM-YYYY   Override date for folder naming
  KSPEC_FAST=1            Non-interactive mode (CI/headless)
  KSPEC_FORCE=1           Overwrite existing agents on /init
  KSPEC_DEBUG=1           Enable debug output

Structure:
  .kiro/steering/         Authoritative project rules
  .kiro/agents/           kspec agent configurations
  .kspec/standards/       Derived standards (from steering)
  .kspec/specs/           Feature specifications
  .kspec/quick/           Quick task logs
  .kspec/debug/           Debug session logs
  .kspec/memory/          Decisions, glossary, follow-ups
EOF
}

# ---------- Main ----------

cmd="${1:-/help}"
shift || true

case "$cmd" in
  /init)                    cmd_init "$@" ;;
  /status)                  cmd_status "$@" ;;
  /progress)                cmd_progress "$@" ;;
  /agents)                  cmd_agents "$@" ;;
  /analyse|/analyze)        cmd_analyse "$@" ;;
  /apply-standards)         cmd_apply_standards "$@" ;;
  /create-spec)             cmd_create_spec "$@" ;;
  /create-tasks)            cmd_create_tasks "$@" ;;
  /execute-tasks)           cmd_execute_tasks "$@" ;;
  /harvest-memory)          cmd_harvest_memory "$@" ;;
  /quick)                   cmd_quick "$@" ;;
  /debug)                   cmd_debug "$@" ;;
  /review)                  cmd_review "$@" ;;
  /test)                    cmd_test "$@" ;;
  /check-consistency)       cmd_check_consistency "$@" ;;
  /reconcile-rules-standards) cmd_reconcile_rules_standards "$@" ;;
  /help|-h|--help|"")       cmd_show_help ;;
  *)
    die "Unknown command: $cmd (run 'kspec /help' for usage)"
    ;;
esac
