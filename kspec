#!/usr/bin/env bash
set -euo pipefail

# kspec — Spec-driven workflow for Kiro CLI (Q-compatible)
# - AU date folders: .kspec/specs/DD-MM-YYYY-<slug>/
# - /init: scaffolds .kspec templates, Project Steering (.kiro/steering/*), and Kiro/Q CLI agents (.kiro/agents/*)
# - Phase gating + review gates: ANALYZE (read-only) → APPLY → CREATE-SPEC → CREATE-TASKS → EXECUTE
# - OAS sync, memory harvesting, CI checks, and fast/headless mode
#
# Environment:
#   QOS_DATE=DD-MM-YYYY   override date used for folder naming
#   QOS_FAST=1            add --no-interactive (good for CI/headless)
#   QOS_FORCE=1           allow /init to overwrite existing agent JSONs
#   QOS_AUTO_EXEC=0       disable automatic command execution (default: enabled)
#   QOS_EXEC_DRY_RUN=1    show commands without executing (overrides QOS_AUTO_EXEC)

QOS_DIR=".kspec"
AGENTS_DIR=".kiro/agents"
RULES_DIR=".kiro/steering"
CURRENT_SPEC_FILE="${QOS_DIR}/.current_spec"
TODAY="${QOS_DATE:-$(date +%d-%m-%Y)}"   # AU format

die(){ printf 'Error: %s\n' "$*" >&2; exit 1; }
slugify(){ 
  # Take first 50 chars, convert to lowercase, replace spaces with hyphens, remove special chars
  printf '%s' "$1" | head -c 50 | tr '[:upper:]' '[:lower:]' | sed -E 's/[[:space:]]+/-/g; s/[^a-z0-9_-]+//g; s/^-+|-+$//g'; 
}
ensure_dir(){ mkdir -p "$1"; }
exists(){ [[ -e "$1" ]]; }
read_or_empty(){ [[ -f "$1" ]] && cat "$1" || printf ''; }

# Find existing spec folder by slug (searches all dates)
find_spec_folder(){
  local slug="$1"
  local current_spec
  
  # First, check if there's a current spec pointer
  if [[ -f "${CURRENT_SPEC_FILE}" ]]; then
    current_spec="$(cat "${CURRENT_SPEC_FILE}")"
    # Check if current spec matches the slug
    if [[ -d "$current_spec" && "$current_spec" == *"${slug}"* ]]; then
      printf '%s' "$current_spec"
      return 0
    fi
  fi
  
  # Find all folders matching the slug pattern
  local matches
  mapfile -t matches < <(find "${QOS_DIR}/specs" -maxdepth 1 -type d -name "*${slug}*" 2>/dev/null | sort -r)
  
  if [[ ${#matches[@]} -eq 0 ]]; then
    return 1
  elif [[ ${#matches[@]} -eq 1 ]]; then
    printf '%s' "${matches[0]}"
    return 0
  else
    # Multiple matches found
    printf 'Multiple spec folders found matching "%s":\n' "$slug" >&2
    local i=1
    for match in "${matches[@]}"; do
      printf '  %d) %s\n' "$i" "$(basename "$match")" >&2
      ((i++))
    done
    printf '\nPlease specify the exact folder name or use a more specific feature name.\n' >&2
    printf 'Tip: Use the full date prefix (DD-MM-YYYY-slug) to be specific.\n' >&2
    return 1
  fi
}

# Get current spec or prompt user to select one
get_or_select_spec(){
  local current_spec
  
  # Check if there's a current spec
  if [[ -f "${CURRENT_SPEC_FILE}" ]]; then
    current_spec="$(cat "${CURRENT_SPEC_FILE}")"
    if [[ -d "$current_spec" ]]; then
      printf '%s' "$current_spec"
      return 0
    fi
  fi
  
  # No current spec, find all specs
  local specs
  mapfile -t specs < <(find "${QOS_DIR}/specs" -maxdepth 1 -type d ! -name "specs" 2>/dev/null | sort -r)
  
  if [[ ${#specs[@]} -eq 0 ]]; then
    die "No spec folders found. Run /create-spec first."
  elif [[ ${#specs[@]} -eq 1 ]]; then
    # Only one spec, use it
    printf '%s' "${specs[0]}"
    printf '%s\n' "${specs[0]}" > "${CURRENT_SPEC_FILE}"
    return 0
  else
    # Multiple specs, prompt user
    printf 'Multiple spec folders found. Please select one:\n' >&2
    local i=1
    for spec in "${specs[@]}"; do
      printf '  %d) %s\n' "$i" "$(basename "$spec")" >&2
      ((i++))
    done
    printf '\nEnter number (1-%d): ' "${#specs[@]}" >&2
    read -r selection
    
    if [[ "$selection" =~ ^[0-9]+$ ]] && [[ "$selection" -ge 1 ]] && [[ "$selection" -le "${#specs[@]}" ]]; then
      local selected_spec="${specs[$((selection-1))]}"
      printf '%s' "$selected_spec"
      printf '%s\n' "$selected_spec" > "${CURRENT_SPEC_FILE}"
      return 0
    else
      die "Invalid selection. Please run the command again."
    fi
  fi
}

# Add QOS_FAST flags
kspec_chat_flags(){
  if [[ "${QOS_FAST:-0}" = "1" ]]; then
    printf -- "--no-interactive"
  else
    printf ''
  fi
}

# Detect CLI binary (Kiro preferred, Q fallback)
detect_cli_bin(){
  if command -v kiro-cli >/dev/null 2>&1; then
    printf 'kiro-cli'
  elif command -v q >/dev/null 2>&1; then
    printf 'q'
  else
    die "Neither 'kiro-cli' nor 'q' found on PATH. Install Kiro CLI or Amazon Q CLI first."
  fi
}

CLI_BIN="${CLI_BIN:-$(detect_cli_bin)}"

info(){
  printf '[kspec] %s\n' "$*"
}

debug(){
  if [[ "${QOS_DEBUG:-0}" = "1" ]]; then
    printf '[kspec:debug] %s\n' "$*"
  fi
}

# ---------- Core paths and helpers ----------

ensure_core_dirs(){
  ensure_dir "${QOS_DIR}/instructions/core"
  ensure_dir "${QOS_DIR}/instructions/meta"
  ensure_dir "${QOS_DIR}/standards"
  ensure_dir "${QOS_DIR}/specs"
  ensure_dir "${QOS_DIR}/tasks"
  ensure_dir "${QOS_DIR}/memory"
  ensure_dir "${QOS_DIR}/examples"
  ensure_dir "${AGENTS_DIR}"
  ensure_dir "${RULES_DIR}"
}

# ---------- Built-in templates (used if repo/global templates absent) ----------
builtin_pre_flight(){ cat <<'MD'
# Pre-Flight
- Detect language/framework, build tool, test runner.
- Verify env & secrets; confirm branch/commit conventions.
- Identify sub-tasks suited for TDD; outline risk gates.
MD
}
builtin_analysis(){ cat <<'MD'
# Analysis
- Primary tech stack, frameworks, libraries.
- Key bounded contexts / domains.
- Observed architecture patterns (layers, modules, boundaries).
- Risks, smells, and complexity hotspots.
MD
}
builtin_standards_tech_stack(){ cat <<'MD'
# Tech Stack Standards
- Document primary languages/frameworks and minimum supported versions.
- Document build tools, package managers, and test runners.
- Document supported deployment targets and environments.
MD
}
builtin_standards_code_style(){ cat <<'MD'
# Code Style & Structure
- Enforce consistent naming conventions and file/folder layout.
- Use linters/formatters appropriate for each language.
- Document module boundaries and domain ownership.
MD
}
builtin_meta_feature(){ cat <<'MD'
# Feature Meta
- Business owner:
- Tech owner:
- Related tickets/links:
- Non-functional requirements (performance, security, compliance):
MD
}
builtin_spec_lite(){ cat <<'MD'
# Spec Lite

## Summary
- Short description of the feature/change.

## Acceptance Criteria
- [ ] Criterion 1
- [ ] Criterion 2

## Risks & Assumptions
- Risks:
- Assumptions:
MD
}
builtin_tasks_template(){ cat <<'MD'
# Tasks

1. [ ] Task 1
2. [ ] Task 2
3. [ ] Task 3
MD
}
builtin_memory_template(){ cat <<'MD'
# Memory

## Decisions
- Decision 1

## Glossary
- Term: Definition

## Follow-ups
- [ ] Follow-up 1
MD
}

# ---------- Agent authoring ----------

write_agent(){
  local name="$1" content="$2" path
  path="${AGENTS_DIR}/${name}.json"

  if [[ -f "$path" && "${QOS_FORCE:-0}" != "1" ]]; then
    printf 'Agent exists, skipping: %s\n' "$path"
    return 0
  fi

  printf '%s\n' "$content" > "$path"
  printf 'Agent written: %s\n' "$path"
}

author_agents(){
  mkdir -p "${AGENTS_DIR}"

  # NOTE:
  # These agents use Kiro CLI's built-in tool names with toolsSettings for permissions.

  write_agent "kspec-analyse" "$(cat <<'JSON'
{
  "name": "kspec-analyse",
  "description": "Read-only analysis; propose standards diffs; never write.",
  "prompt": "Analyse the repository. Deliver: (1) primary tech stack and architecture overview, (2) identified bounded contexts/domains, (3) risks/smells, (4) suggestions for improving standards and steering docs. Use .kiro/steering/*.md as the authoritative rules and .kspec/standards/*.md as derived standards. Do not modify any files; operate read-only. At the end, summarise next recommended kspec phase.",
  "allowedTools": ["read"],
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    }
  }
}
JSON
)"

  write_agent "kspec-apply-standards" "$(cat <<'JSON'
{
  "name": "kspec-apply-standards",
  "description": "Apply or propose changes to .kspec/standards based on steering docs and repo reality.",
  "prompt": "Goal: Align .kspec/standards with .kiro/steering and actual repo state. Steps: (1) Read .kiro/steering/*.md and .kspec/standards/*.md, (2) Propose specific edits to bring standards into compliance with steering while reflecting reality, (3) When asked, write updated standards markdown files under .kspec/standards. Be explicit about any deviations or approved exceptions. Treat .kiro/steering as authoritative.",
  "allowedTools": ["read", "write"],
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/standards/**"]
    }
  }
}
JSON
)"

  write_agent "kspec-create-spec" "$(cat <<'JSON'
{
  "name": "kspec-create-spec",
  "description": "Create spec.md and spec-lite.md for a feature; use steering and standards snapshot.",
  "prompt": "You are creating a feature specification. The feature folder path will be provided in the user message. IMPORTANT: Use the 'read' tool to read files and directories. To read a directory, use read with mode 'Directory'. To read files, use read with mode 'Line'. Steps: (1) Use read tool to list .kiro/steering/ directory, (2) Use read tool to read each steering file, (3) Use read tool to list .kspec/standards/ directory, (4) Use read tool to read each standards file, (5) Use write tool to create spec.md in the feature folder with: problem/context, requirements (functional + non-functional), constraints, high-level design, and references to steering docs, (6) Use write tool to create spec-lite.md with a condensed version. If there are conflicts between steering and standards, treat .kiro/steering as authoritative. At the end, suggest: run kspec /create-tasks with the feature name.",
  "allowedTools": ["read", "write"],
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/specs/**"]
    }
  }
}
JSON
)"

  write_agent "kspec-create-tasks" "$(cat <<'JSON'
{
  "name": "kspec-create-tasks",
  "description": "Turn spec.md into a numbered, TDD-ready tasks.md using the standards snapshot.",
  "prompt": "You are creating implementation tasks from a feature specification. The feature folder path will be provided in the user message. Read the spec.md and spec-lite.md from the feature folder and generate or refine tasks.md as a numbered, TDD-friendly checklist. CRITICAL: Use checkbox format for all tasks: '1. [ ] Task description'. This enables task completion tracking and resume functionality. Reference specific spec sections for each task. Assume .kspec/standards and .kiro/steering are in sync; if you notice contradictions, call them out and propose a follow-up standards reconcile. At the end, suggest the next step: run kspec /execute-tasks with the feature name.",
  "allowedTools": ["read", "write"],
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/specs/**"]
    }
  }
}
JSON
)"

  write_agent "kspec-execute-tasks" "$(cat <<'JSON'
{
  "name": "kspec-execute-tasks",
  "description": "Guided execution with automatic command execution by default.",
  "prompt": "You are executing implementation tasks. The feature folder path will be provided in the user message. Execute tasks using TDD: for each task in tasks.md, (1) identify incomplete tasks ([ ] checkboxes), (2) resume from first incomplete task, (3) restate the goal, (4) propose code changes, (5) propose tests, (6) suggest and execute commands, (7) CRITICAL: mark task complete by updating tasks.md - change [ ] to [x]. By default, commands are executed automatically (QOS_AUTO_EXEC=1 by default). Set QOS_AUTO_EXEC=0 to disable automatic execution, or QOS_EXEC_DRY_RUN=1 to only show commands without executing. Never run destructive commands without explicit confirmation. Always log executed commands to execution.log in the feature folder. After completing each task, write the updated tasks.md file with [x] for completed tasks to enable resume functionality.",
  "allowedTools": ["read", "write", "shell"],
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/specs/**", "./**"]
    },
    "shell": {
      "autoAllowReadonly": true
    }
  }
}
JSON
)"

  write_agent "kspec-harvest-memory" "$(cat <<'JSON'
{
  "name": "kspec-harvest-memory",
  "description": "Summarise decisions, glossary, and follow-ups into .kspec/memory.",
  "prompt": "Read relevant specs, tasks, and recent changes under .kspec/specs, .kspec/tasks, and the repo. Summarise: (1) key decisions, (2) glossary of terms, (3) follow-ups and risks. Write or update files under .kspec/memory (e.g., decisions.md, glossary.md, follow-ups.md). Call out where steering docs (.kiro/steering) should be updated and propose concrete edits.",
  "allowedTools": ["read", "write"],
  "toolsSettings": {
    "read": {
      "allowedPaths": [".kiro/**", ".kspec/**", "./**"]
    },
    "write": {
      "allowedPaths": [".kspec/memory/**"]
    }
  }
}
JSON
)"
}

# ---------- Standards / steering helpers ----------

rules_fingerprint(){
  # portable fingerprint of all rule files (order-insensitive)
  local hash_cmd
  if command -v sha256sum >/dev/null 2>&1; then
    hash_cmd="sha256sum"
  elif command -v shasum >/dev/null 2>&1; then
    hash_cmd="shasum -a 256"
  else
    die "Neither sha256sum nor shasum found. Cannot compute fingerprint."
  fi
  
  find "${RULES_DIR}" -type f -maxdepth 1 2>/dev/null \
    | sort \
    | xargs cat 2>/dev/null \
    | $hash_cmd \
    | awk '{print $1}'
}

read_rules_fingerprint(){
  [[ -f "${QOS_DIR}/.rules_fingerprint" ]] && cat "${QOS_DIR}/.rules_fingerprint" || printf ''
}

write_rules_fingerprint(){
  rules_fingerprint > "${QOS_DIR}/.rules_fingerprint"
}

check_steering_drift(){
  local current_fp stored_fp
  current_fp="$(rules_fingerprint)"
  stored_fp="$(read_rules_fingerprint)"
  
  if [[ -n "$stored_fp" && "$current_fp" != "$stored_fp" ]]; then
    printf '⚠️  Warning: Steering docs have changed since last sync.\n' >&2
    printf '   Run: kspec /apply-standards\n' >&2
    printf '   Continue anyway? (y/N): ' >&2
    read -r response
    [[ "$response" =~ ^[Yy]$ ]] || exit 1
  fi
}

get_context_block(){
  # Project-level context that kspec agents should always see.
  # Steering (.kiro/steering) and agents (.kiro/agents) are auto-included by Kiro.
  # We include examples & memory explicitly where helpful.
  cat <<EOF
kspec context:
- Today: ${TODAY}
- kspec dir: ${QOS_DIR}/
- Steering: ${RULES_DIR}/ (authoritative project rules)
- Standards: ${QOS_DIR}/standards/ (derived from steering)
- Specs: ${QOS_DIR}/specs/
- Tasks: ${QOS_DIR}/tasks/
- Memory: ${QOS_DIR}/memory/
EOF
}

# ---------- Commands ----------

cmd_init(){
  info "Initializing kspec..."

  ensure_core_dirs

  # Instructions templates
  [[ -f "${QOS_DIR}/instructions/core/pre-flight.md" ]] || builtin_pre_flight > "${QOS_DIR}/instructions/core/pre-flight.md"
  [[ -f "${QOS_DIR}/instructions/core/analysis.md" ]]   || builtin_analysis > "${QOS_DIR}/instructions/core/analysis.md"
  [[ -f "${QOS_DIR}/instructions/meta/feature.md" ]]    || builtin_meta_feature > "${QOS_DIR}/instructions/meta/feature.md"
  [[ -f "${QOS_DIR}/standards/tech-stack.md" ]]         || builtin_standards_tech_stack > "${QOS_DIR}/standards/tech-stack.md"
  [[ -f "${QOS_DIR}/standards/code-style.md" ]]         || builtin_standards_code_style > "${QOS_DIR}/standards/code-style.md"
  [[ -f "${QOS_DIR}/memory/template.md" ]]              || builtin_memory_template > "${QOS_DIR}/memory/template.md"
  [[ -f ".kspec/examples/spec-lite.example.md" ]]         || builtin_spec_lite > ".kspec/examples/spec-lite.example.md"
  [[ -f ".kspec/examples/tasks.example.md" ]]             || builtin_tasks_template > ".kspec/examples/tasks.example.md"
  printf 'Initialized %s templates\n' "${QOS_DIR}"

  # Kiro steering docs (foundational files per Kiro documentation)
  mkdir -p "${RULES_DIR}"
  
  [[ -f "${RULES_DIR}/product.md" ]] || cat > "${RULES_DIR}/product.md" <<'MD'
# Product Overview

## Purpose
Define your product's purpose, target users, key features, and business objectives.

## Target Users
- Who are the primary users?
- What problems are we solving for them?

## Key Features
- List the main features and capabilities
- Prioritize by importance

## Business Objectives
- What are the success metrics?
- What are the business goals?

## Technical Constraints
- Compliance requirements (e.g., SOC2, GDPR)
- Performance requirements
- Scalability needs
MD

  [[ -f "${RULES_DIR}/tech.md" ]] || cat > "${RULES_DIR}/tech.md" <<'MD'
# Technology Stack

## Runtime & Languages
- Primary language and version
- Runtime environment

## Frameworks & Libraries
- Web framework
- Testing framework
- Key libraries

## Development Tools
- Build tools
- Package managers
- Linters and formatters

## Infrastructure
- Deployment targets
- Cloud providers
- CI/CD tools

## Technical Constraints
- Minimum supported versions
- Deprecated technologies to avoid
- Required dependencies
MD

  [[ -f "${RULES_DIR}/structure.md" ]] || cat > "${RULES_DIR}/structure.md" <<'MD'
# Project Structure

## File Organization
- Directory structure and layout
- Module boundaries
- Feature-based vs layer-based organization

## Naming Conventions
- File naming patterns
- Variable naming (camelCase, snake_case, etc.)
- Class and function naming
- Constants and environment variables

## Import Patterns
- Import ordering
- Absolute vs relative imports
- Barrel exports

## Architectural Decisions
- Design patterns used
- Separation of concerns
- Dependency injection approach
- State management strategy

## Code Organization
- Where to put business logic
- Where to put utilities
- Where to put types/interfaces
- Where to put tests
MD

  # Additional custom steering files
  [[ -f "${RULES_DIR}/api-standards.md" ]] || cat > "${RULES_DIR}/api-standards.md" <<'MD'
# API Standards

## REST Conventions
- Endpoint naming patterns
- HTTP methods usage
- Status codes
- Versioning strategy

## Request/Response Format
- JSON structure
- Error response format
- Pagination approach
- Filtering and sorting

## Authentication & Authorization
- Authentication method (JWT, OAuth, etc.)
- Authorization patterns
- Token management

## Documentation
- OpenAPI/Swagger requirements
- Endpoint documentation standards
- Example requests/responses
MD

  [[ -f "${RULES_DIR}/testing-standards.md" ]] || cat > "${RULES_DIR}/testing-standards.md" <<'MD'
# Testing Standards

## Testing Approach
- TDD (Test-Driven Development) required
- Test-first methodology
- Red → Green → Refactor cycle

## Test Types
- Unit tests: Test individual functions/methods
- Integration tests: Test component interactions
- E2E tests: Test complete user flows

## Testing Libraries
- Unit test framework
- Assertion library
- Mocking approach

## Coverage Requirements
- Minimum coverage thresholds
- Critical paths that must be tested
- What to test vs what to skip

## Test Organization
- Test file naming
- Test file location
- Test structure and patterns
MD

  [[ -f "${RULES_DIR}/security.md" ]] || cat > "${RULES_DIR}/security.md" <<'MD'
# Security Standards

## Authentication & Authorization
- Authentication requirements
- Authorization patterns
- Session management

## Data Protection
- Encryption requirements
- Sensitive data handling
- PII protection

## Input Validation
- Input sanitization rules
- Validation patterns
- SQL injection prevention
- XSS prevention

## Secrets Management
- Never commit secrets to code
- Use environment variables
- Secret rotation policies

## Logging & Monitoring
- What to log
- What NOT to log (passwords, tokens, PII)
- Security event monitoring
MD

  printf 'Initialized Kiro Steering docs in %s\n' "${RULES_DIR}"

  # Agents (idempotent; set QOS_FORCE=1 to overwrite)
  author_agents
  printf 'Agents initialised in %s\n' "${AGENTS_DIR}"

  printf '\nUse either the script or agents:\n'
  printf '  Script: kspec /analyse | /apply-standards | /create-spec "Feature" | /create-tasks | /execute-tasks\n'
  printf '  Agent:  %s chat --agent kspec-analyse\n' "${CLI_BIN}"

  write_rules_fingerprint

  info "kspec init complete."
}

cmd_analyse(){
  info "Running project analysis..."

  local msg="Analyse the entire repository and project.

Deliver:
1. Primary tech stack and architecture overview
   - Languages, frameworks, libraries used
   - Build tools, package managers, test runners
   - Deployment targets and environments
2. Identified bounded contexts/domains
   - Key modules and their responsibilities
   - Domain boundaries and relationships
3. Risks, smells, and complexity hotspots
   - Code quality issues
   - Technical debt
   - Security concerns
   - Performance bottlenecks
4. Suggestions for improving standards and steering docs
   - Recommended updates to .kiro/steering/*.md
   - Recommended updates to .kspec/standards/*.md
   - Gaps in current documentation

Use .kiro/steering/*.md as the authoritative rules and .kspec/standards/*.md as derived standards.
Do not modify any files; operate read-only.

At the end, summarise:
- Current state of the project
- Recommended next steps for kspec setup
- Suggested standards to add or update
- Next recommended kspec phase (e.g., run /apply-standards)

$(get_context_block)"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_apply_standards(){
  info "Running apply-standards phase..."

  local msg="Align .kspec/standards with .kiro/steering and repo reality.

Steps:
1. Read .kiro/steering/*.md (project rules - authoritative)
2. Read .kspec/standards/*.md (current standards - derived)
3. Analyze repo to understand actual tech stack and practices
4. Identify gaps and conflicts between steering, standards, and reality
5. Propose specific edits to bring standards into compliance
6. Write updated standards markdown files under .kspec/standards

Deliverables:
- Updated .kspec/standards/tech-stack.md with:
  * Languages, frameworks, versions
  * Build tools and package managers
  * Test runners and CI/CD tools
  * Deployment targets
- Updated .kspec/standards/code-style.md with:
  * Naming conventions
  * File/folder structure
  * Linting and formatting rules
  * Module boundaries

Be explicit about:
- Any deviations from steering docs (with justification)
- Approved exceptions
- Conflicts that need steering doc updates

Treat .kiro/steering as authoritative.

At the end, summarise:
- What was updated
- Any conflicts found
- Recommended steering doc updates

$(get_context_block)"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"

  write_rules_fingerprint
}

cmd_create_spec(){
  local feature="${1:-}"
  [[ -n "$feature" ]] || die "Usage: kspec /create-spec \"Feature Name\""

  check_steering_drift

  local slug folder msg
  slug="$(slugify "$feature")"
  folder="${QOS_DIR}/specs/${TODAY}-${slug}"
  ensure_dir "$folder"

  printf '%s\n' "$folder" > "${CURRENT_SPEC_FILE}"

  msg="Create a feature specification for: ${feature}

Feature folder: ${folder}

Instructions:
1. Read the steering documents from .kiro/steering/ directory
2. Read the standards from .kspec/standards/ directory
3. Create ${folder}/spec.md with:
   - Problem/Context section
   - Functional Requirements
   - Non-Functional Requirements
   - Constraints
   - High-Level Design
   - References to steering docs
4. Create ${folder}/spec-lite.md with a condensed version

The steering docs (.kiro/steering/) are authoritative. If there are conflicts with standards, note them.

At the end, suggest: Next step → run: kspec /create-tasks \"${feature}\"

$(get_context_block)"

  info "Feature folder: ${folder}"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_create_tasks(){
  local feature="${1:-}"
  local folder msg
  
  check_steering_drift
  
  if [[ -n "$feature" ]]; then
    # Feature name provided, find by slug
    local slug
    slug="$(slugify "$feature")"
    folder="$(find_spec_folder "$slug")"
    
    if [[ -z "$folder" || ! -d "$folder" ]]; then
      die "Feature folder not found for '${feature}'. Run /create-spec first."
    fi
  else
    # No feature name, use current spec or prompt
    folder="$(get_or_select_spec)"
  fi

  msg="Generate implementation tasks from the feature specification.

Feature folder: ${folder}

Instructions:
1. Read ${folder}/spec.md and ${folder}/spec-lite.md thoroughly
2. Generate ${folder}/tasks.md as a numbered, TDD-friendly checklist

Task Format:
- CRITICAL: Use checkbox format for all tasks: \"1. [ ] Task description\"
- This enables task completion tracking and resume functionality
- Example format:
  1. [ ] Create user model with validation
  2. [ ] Implement authentication service
  3. [ ] Add API endpoints for user management

Task Structure:
- Group tasks by user story or feature area
- For each task, specify:
  * Task number and description with [ ] checkbox
  * Test to write first (TDD approach)
  * Implementation steps
  * Acceptance criteria
  * Dependencies on other tasks
- Mark tasks that can run in parallel with [P]
- Include file paths where changes should occur

Task Ordering:
- Models/types first
- Services/business logic second
- API endpoints/controllers third
- UI components last
- Tests before implementation for each layer

Reference specific spec sections for each task.
Assume .kspec/standards and .kiro/steering are in sync.
If you notice contradictions, call them out and propose a follow-up standards reconcile.

At the end, summarise:
- Total number of tasks
- Estimated complexity
- Critical path tasks
- Suggest: Next step → run: kspec /execute-tasks

$(get_context_block)"

  info "Feature folder: ${folder}"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_execute_tasks(){
  local feature="${1:-}"
  local folder msg
  
  check_steering_drift
  
  if [[ -n "$feature" ]]; then
    # Feature name provided, find by slug
    local slug
    slug="$(slugify "$feature")"
    folder="$(find_spec_folder "$slug")"
    
    if [[ -z "$folder" || ! -d "$folder" ]]; then
      die "Feature folder not found for '${feature}'. Run /create-spec and /create-tasks first."
    fi
  else
    # No feature name, use current spec or prompt
    folder="$(get_or_select_spec)"
  fi

  msg="Execute implementation tasks using TDD approach.

Feature folder: ${folder}

CRITICAL SAFETY RULES:
⚠️  NEVER delete, remove, or modify .kiro/ or .kspec/ folders
⚠️  NEVER run commands that would overwrite these folders
⚠️  If a tool complains about .kiro/ or .kspec/ existing, work around it
⚠️  These folders contain project governance and specs - they are sacred
⚠️  If initialization tools conflict, use subdirectories or different approaches

Instructions:
1. Read ${folder}/tasks.md and ${folder}/spec.md
2. Identify incomplete tasks (those with [ ] checkboxes)
3. Resume from the first incomplete task
4. For each task in order:
   a) Restate the task goal and acceptance criteria
   b) Write the test first (TDD)
   c) Propose minimal code changes to make test pass
   d) Refactor if needed
   e) Suggest commands to run (build, test, lint)
   f) IMPORTANT: Mark task as complete by updating tasks.md - change [ ] to [x]
   g) Write the updated tasks.md file after each completed task

Task Completion:
- CRITICAL: After completing each task, update ${folder}/tasks.md
- Change the checkbox from [ ] to [x] for completed tasks
- Example: \"1. [ ] Task name\" becomes \"1. [x] Task name\"
- This enables resume functionality for interrupted work
- Always write the full updated tasks.md file

Resume Capability:
- If tasks.md has [x] marked tasks, skip them and resume from first [ ]
- Report which tasks are already complete
- Continue from where work was interrupted

Execution Strategy:
- Follow TDD: Red → Green → Refactor
- Write tests before implementation
- Keep changes minimal and focused
- Run tests after each task
- Mark task complete in tasks.md after tests pass
- Commit after each completed task (suggest commit message)

Command Execution:
- IMPORTANT: Always use non-interactive flags for commands
  * Use --yes, --no-interaction, -y flags where available
  * For npm: use --yes or -y
  * For create-next-app: use --yes or answer prompts with defaults
  * For package managers: use --non-interactive or --yes
- If tools complain about existing files/folders:
  * Create in subdirectories instead
  * Use --force only if safe (never for .kiro/ or .kspec/)
  * Modify the approach to work with existing structure
- By default, commands are executed automatically (QOS_AUTO_EXEC=1)
- Set QOS_AUTO_EXEC=0 to disable automatic execution
- Set QOS_EXEC_DRY_RUN=1 to only show commands without executing
- Never run destructive commands without explicit confirmation
- If a command requires user input, modify it to be non-interactive

Logging:
- Log all executed commands to ${folder}/execution.log
- Include timestamps and exit codes
- Note any errors or warnings

At the end, summarise:
- Tasks completed (X of Y)
- Tasks remaining
- Tests passing
- Any issues encountered
- If all tasks complete, suggest: Next step → run: kspec /harvest-memory
- If tasks remain, note that you can resume by running /execute-tasks again

$(get_context_block)"

  info "Feature folder: ${folder}"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_harvest_memory(){
  local feature="${1:-}"
  local folder=""
  
  if [[ -n "$feature" ]]; then
    # Feature name provided, find by slug
    local slug
    slug="$(slugify "$feature")"
    folder="$(find_spec_folder "$slug")"
    
    if [[ -z "$folder" || ! -d "$folder" ]]; then
      die "Feature folder not found for '${feature}'."
    fi
  else
    # No feature name, use current spec or prompt
    folder="$(get_or_select_spec)"
  fi
  
  info "Running memory harvest for: ${folder}"

  local msg="Harvest memory from the feature work.

Feature folder: ${folder}

Instructions:
1. Read ${folder}/spec.md, ${folder}/tasks.md, ${folder}/execution.log
2. Read recent changes in the repo related to this feature (git log, diffs)
3. Analyze implementation decisions and patterns used

Deliverables:

Create/Update .kspec/memory/decisions.md:
- Key architectural decisions made
- Technology choices and rationale
- Trade-offs considered
- Alternatives rejected and why
- Date and context for each decision

Create/Update .kspec/memory/glossary.md:
- Domain-specific terms and definitions
- Technical concepts introduced
- Acronyms and abbreviations
- Business terminology
- Links to relevant documentation

Create/Update .kspec/memory/follow-ups.md:
- Technical debt identified
- Future improvements needed
- Performance optimizations to consider
- Security concerns to address
- Refactoring opportunities
- Dependencies to upgrade

Steering Doc Updates:
- Identify patterns that should become standards
- Suggest updates to .kiro/steering/*.md
- Propose new steering docs if needed
- Note any deviations from current steering

At the end, summarise:
- Key learnings captured
- Number of decisions documented
- Critical follow-ups
- Recommended steering updates

$(get_context_block)"

  "${CLI_BIN}" chat $(kspec_chat_flags) "$msg"
}

cmd_check_consistency(){
  info "Checking consistency between steering and standards..."

  local prompt="Check consistency between steering docs and kspec standards.

Steps:
1. Read .kiro/steering/*.md (project rules / constitution)
2. Read .kspec/standards/tech-stack.md and .kspec/standards/code-style.md (repo project standards)
3. Identify contradictions, gaps, and outdated sections
4. Summarise findings and recommend follow-ups (e.g., run /apply-standards)

DO NOT modify any files; this is read-only analysis."

  "${CLI_BIN}" chat $(kspec_chat_flags) "$prompt"
}

cmd_reconcile_rules_standards(){
  info "Reconciling steering (.kiro/steering) and standards (.kspec/standards)..."

  local prompt="Align .kspec/standards with .kiro/steering.

Steps:
1. Read .kiro/steering/*.md and the standards files
2. Propose specific edits to bring standards into compliance with steering while reflecting repo reality
3. Summarise the changes you recommend making

Do not modify files yourself during this run; just propose edits that can be applied by /apply-standards."

  "${CLI_BIN}" chat $(kspec_chat_flags) "$prompt"
}

cmd_status(){
  info "kspec Status"
  printf '\n'
  
  printf 'Environment:\n'
  printf '  CLI Binary: %s\n' "${CLI_BIN}"
  printf '  Date: %s\n' "${TODAY}"
  printf '  QOS_FAST: %s\n' "${QOS_FAST:-0}"
  printf '  QOS_FORCE: %s\n' "${QOS_FORCE:-0}"
  printf '  QOS_AUTO_EXEC: %s (default: 1)\n' "${QOS_AUTO_EXEC:-1}"
  printf '  QOS_EXEC_DRY_RUN: %s\n' "${QOS_EXEC_DRY_RUN:-0}"
  printf '  QOS_DEBUG: %s\n' "${QOS_DEBUG:-0}"
  printf '\n'
  
  if [[ -f "${CURRENT_SPEC_FILE}" ]]; then
    printf 'Current Spec: %s\n' "$(cat "${CURRENT_SPEC_FILE}")"
  else
    printf 'Current Spec: (none)\n'
  fi
  printf '\n'
  
  if [[ -f "${QOS_DIR}/.rules_fingerprint" ]]; then
    printf 'Steering Fingerprint: %s\n' "$(cat "${QOS_DIR}/.rules_fingerprint")"
  else
    printf 'Steering Fingerprint: (not initialized)\n'
  fi
  printf '\n'
  
  if [[ -d "${QOS_DIR}" ]]; then
    printf 'Initialized: yes\n'
    printf 'Specs: %d\n' "$(find "${QOS_DIR}/specs" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l | tr -d ' ')"
  else
    printf 'Initialized: no (run: kspec /init)\n'
  fi
}

cmd_show_help(){
  cat <<EOF
kspec - Spec-driven workflow for Kiro CLI (Q-compatible)

Usage:
  kspec /init
  kspec /status
  kspec /analyse
  kspec /apply-standards
  kspec /create-spec "Feature Name"
  kspec /create-tasks ["Feature Name"]
  kspec /execute-tasks ["Feature Name"]
  kspec /harvest-memory ["Feature Name"]
  kspec /check-consistency
  kspec /reconcile-rules-standards

Examples:
  # Initial setup
  kspec /init                            # Initialize kspec structure
  kspec /analyse                         # Analyze project and suggest standards
  kspec /apply-standards                 # Update standards based on analysis
  
  # Feature development
  kspec /create-spec "User Authentication API"
  kspec /create-tasks                    # Uses current spec
  kspec /execute-tasks                   # Uses current spec
  kspec /harvest-memory                  # Uses current spec

Notes:
  - /analyse is project-level: analyzes entire codebase and suggests standards
  - Feature name is required only for /create-spec
  - Other feature commands use the current spec by default
  - If multiple specs exist, you'll be prompted to select one
  - You can override by providing a feature name

Steering:
  - Authoritative project rules live under .kiro/steering/.
  - Derived standards live under .kspec/standards/.
  - Specs and tasks live under .kspec/specs/.

Agents (per-project):
  - .kiro/agents/kspec-analyse.json
  - .kiro/agents/kspec-apply-standards.json
  - .kiro/agents/kspec-create-spec.json
  - .kiro/agents/kspec-create-tasks.json
  - .kiro/agents/kspec-execute-tasks.json
  - .kiro/agents/kspec-harvest-memory.json
EOF
}

# ---------- Main ----------

cmd="${1:-/help}"
shift || true

case "$cmd" in
  /init)                    cmd_init "$@" ;;
  /status)                  cmd_status "$@" ;;
  /analyse)                 cmd_analyse "$@" ;;
  /apply-standards)         cmd_apply_standards "$@" ;;
  /create-spec)             cmd_create_spec "$@" ;;
  /create-tasks)            cmd_create_tasks "$@" ;;
  /execute-tasks)           cmd_execute_tasks "$@" ;;
  /harvest-memory)          cmd_harvest_memory "$@" ;;
  /check-consistency)       cmd_check_consistency "$@" ;;
  /reconcile-rules-standards) cmd_reconcile_rules_standards "$@" ;;
  /help|-h|--help|"")       cmd_show_help ;;
  *)
    die "Unknown command: $cmd"
    ;;
esac
